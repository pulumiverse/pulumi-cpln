// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class DomainRoute extends pulumi.CustomResource {
    /**
     * Get an existing DomainRoute resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DomainRouteState, opts?: pulumi.CustomResourceOptions): DomainRoute {
        return new DomainRoute(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'cpln:index/domainRoute:DomainRoute';

    /**
     * Returns true if the given object is an instance of DomainRoute.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DomainRoute {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DomainRoute.__pulumiType;
    }

    /**
     * The self link of the domain to add the route to.
     */
    declare public readonly domainLink: pulumi.Output<string>;
    /**
     * The port the route corresponds to. Default: 443
     */
    declare public readonly domainPort: pulumi.Output<number>;
    /**
     * Modify the headers for all http requests for this route.
     */
    declare public readonly headers: pulumi.Output<outputs.DomainRouteHeaders | undefined>;
    /**
     * This option allows forwarding traffic for different host headers to different workloads. This will only be used when the target GVC has dedicated load balancing enabled and the Domain is configured for wildcard support. Please contact us on Slack or at support@controlplane.com for additional details.
     */
    declare public readonly hostPrefix: pulumi.Output<string | undefined>;
    /**
     * A regex to match the host header. This will only be used when the target GVC has dedicated load balancing enabled and the Domain is configure for wildcard support. Contact your account manager for details.
     */
    declare public readonly hostRegex: pulumi.Output<string | undefined>;
    /**
     * For the linked workload, the port to route traffic to.
     */
    declare public readonly port: pulumi.Output<number | undefined>;
    /**
     * The path will match any unmatched path prefixes for the subdomain.
     */
    declare public readonly prefix: pulumi.Output<string | undefined>;
    /**
     * Used to match URI paths. Uses the google re2 regex syntax.
     */
    declare public readonly regex: pulumi.Output<string | undefined>;
    /**
     * A path prefix can be configured to be replaced when forwarding the request to the Workload.
     */
    declare public readonly replacePrefix: pulumi.Output<string | undefined>;
    /**
     * The replica number of a stateful workload to route to. If not provided, traffic will be routed to all replicas.
     */
    declare public readonly replica: pulumi.Output<number | undefined>;
    /**
     * The link of the workload to map the prefix to.
     */
    declare public readonly workloadLink: pulumi.Output<string>;

    /**
     * Create a DomainRoute resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DomainRouteArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DomainRouteArgs | DomainRouteState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DomainRouteState | undefined;
            resourceInputs["domainLink"] = state?.domainLink;
            resourceInputs["domainPort"] = state?.domainPort;
            resourceInputs["headers"] = state?.headers;
            resourceInputs["hostPrefix"] = state?.hostPrefix;
            resourceInputs["hostRegex"] = state?.hostRegex;
            resourceInputs["port"] = state?.port;
            resourceInputs["prefix"] = state?.prefix;
            resourceInputs["regex"] = state?.regex;
            resourceInputs["replacePrefix"] = state?.replacePrefix;
            resourceInputs["replica"] = state?.replica;
            resourceInputs["workloadLink"] = state?.workloadLink;
        } else {
            const args = argsOrState as DomainRouteArgs | undefined;
            if (args?.domainLink === undefined && !opts.urn) {
                throw new Error("Missing required property 'domainLink'");
            }
            if (args?.workloadLink === undefined && !opts.urn) {
                throw new Error("Missing required property 'workloadLink'");
            }
            resourceInputs["domainLink"] = args?.domainLink;
            resourceInputs["domainPort"] = args?.domainPort;
            resourceInputs["headers"] = args?.headers;
            resourceInputs["hostPrefix"] = args?.hostPrefix;
            resourceInputs["hostRegex"] = args?.hostRegex;
            resourceInputs["port"] = args?.port;
            resourceInputs["prefix"] = args?.prefix;
            resourceInputs["regex"] = args?.regex;
            resourceInputs["replacePrefix"] = args?.replacePrefix;
            resourceInputs["replica"] = args?.replica;
            resourceInputs["workloadLink"] = args?.workloadLink;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DomainRoute.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering DomainRoute resources.
 */
export interface DomainRouteState {
    /**
     * The self link of the domain to add the route to.
     */
    domainLink?: pulumi.Input<string>;
    /**
     * The port the route corresponds to. Default: 443
     */
    domainPort?: pulumi.Input<number>;
    /**
     * Modify the headers for all http requests for this route.
     */
    headers?: pulumi.Input<inputs.DomainRouteHeaders>;
    /**
     * This option allows forwarding traffic for different host headers to different workloads. This will only be used when the target GVC has dedicated load balancing enabled and the Domain is configured for wildcard support. Please contact us on Slack or at support@controlplane.com for additional details.
     */
    hostPrefix?: pulumi.Input<string>;
    /**
     * A regex to match the host header. This will only be used when the target GVC has dedicated load balancing enabled and the Domain is configure for wildcard support. Contact your account manager for details.
     */
    hostRegex?: pulumi.Input<string>;
    /**
     * For the linked workload, the port to route traffic to.
     */
    port?: pulumi.Input<number>;
    /**
     * The path will match any unmatched path prefixes for the subdomain.
     */
    prefix?: pulumi.Input<string>;
    /**
     * Used to match URI paths. Uses the google re2 regex syntax.
     */
    regex?: pulumi.Input<string>;
    /**
     * A path prefix can be configured to be replaced when forwarding the request to the Workload.
     */
    replacePrefix?: pulumi.Input<string>;
    /**
     * The replica number of a stateful workload to route to. If not provided, traffic will be routed to all replicas.
     */
    replica?: pulumi.Input<number>;
    /**
     * The link of the workload to map the prefix to.
     */
    workloadLink?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a DomainRoute resource.
 */
export interface DomainRouteArgs {
    /**
     * The self link of the domain to add the route to.
     */
    domainLink: pulumi.Input<string>;
    /**
     * The port the route corresponds to. Default: 443
     */
    domainPort?: pulumi.Input<number>;
    /**
     * Modify the headers for all http requests for this route.
     */
    headers?: pulumi.Input<inputs.DomainRouteHeaders>;
    /**
     * This option allows forwarding traffic for different host headers to different workloads. This will only be used when the target GVC has dedicated load balancing enabled and the Domain is configured for wildcard support. Please contact us on Slack or at support@controlplane.com for additional details.
     */
    hostPrefix?: pulumi.Input<string>;
    /**
     * A regex to match the host header. This will only be used when the target GVC has dedicated load balancing enabled and the Domain is configure for wildcard support. Contact your account manager for details.
     */
    hostRegex?: pulumi.Input<string>;
    /**
     * For the linked workload, the port to route traffic to.
     */
    port?: pulumi.Input<number>;
    /**
     * The path will match any unmatched path prefixes for the subdomain.
     */
    prefix?: pulumi.Input<string>;
    /**
     * Used to match URI paths. Uses the google re2 regex syntax.
     */
    regex?: pulumi.Input<string>;
    /**
     * A path prefix can be configured to be replaced when forwarding the request to the Workload.
     */
    replacePrefix?: pulumi.Input<string>;
    /**
     * The replica number of a stateful workload to route to. If not provided, traffic will be routed to all replicas.
     */
    replica?: pulumi.Input<number>;
    /**
     * The link of the workload to map the prefix to.
     */
    workloadLink: pulumi.Input<string>;
}

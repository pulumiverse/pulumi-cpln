// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Cpln.Inputs
{

    public sealed class DomainSpecArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Allows domain to accept wildcards. The associated GVC must have dedicated load balancing enabled.
        /// </summary>
        [Input("acceptAllHosts")]
        public Input<bool>? AcceptAllHosts { get; set; }

        /// <summary>
        /// Accept all subdomains will accept any host that is a sub domain of the domain so *.$DOMAIN
        /// </summary>
        [Input("acceptAllSubdomains")]
        public Input<bool>? AcceptAllSubdomains { get; set; }

        /// <summary>
        /// Defines the method used to prove domain ownership for certificate issuance.
        /// </summary>
        [Input("certChallengeType")]
        public Input<string>? CertChallengeType { get; set; }

        /// <summary>
        /// In `Cname` dnsMode, Control Plane will configure workloads to accept traffic for the domain but will not manage DNS records for the domain. End users must configure CNAME records in their own DNS pointed to the canonical workload endpoint. Currently `Cname` dnsMode requires that a TLS server certificate be configured when subdomain based routing is used. In `Ns` dnsMode, Control Plane will manage the subdomains and create all necessary DNS records. End users configure NS records to forward DNS requests to the Control Plane managed DNS servers. Valid values: `Cname`, `Ns`. Default: `Cname`.
        /// </summary>
        [Input("dnsMode")]
        public Input<string>? DnsMode { get; set; }

        /// <summary>
        /// This value is set to a target GVC (using a full link) for use by subdomain based routing. Each workload in the GVC will receive a subdomain in the form ${workload.name}.${domain.name}. **Do not include if path based routing is used.**
        /// </summary>
        [Input("gvcLink")]
        public Input<string>? GvcLink { get; set; }

        [Input("ports")]
        private InputList<Inputs.DomainSpecPortArgs>? _ports;

        /// <summary>
        /// Domain port specifications.
        /// </summary>
        public InputList<Inputs.DomainSpecPortArgs> Ports
        {
            get => _ports ?? (_ports = new InputList<Inputs.DomainSpecPortArgs>());
            set => _ports = value;
        }

        /// <summary>
        /// Creates a unique subdomain for each replica of a stateful workload, enabling direct access to individual instances.
        /// </summary>
        [Input("workloadLink")]
        public Input<string>? WorkloadLink { get; set; }

        public DomainSpecArgs()
        {
        }
        public static new DomainSpecArgs Empty => new DomainSpecArgs();
    }
}
